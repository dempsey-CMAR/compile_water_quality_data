---
title: "CMAR Sensor Validation App"
date: "version 0.0.9000"
output:
  flexdashboard::flex_dashboard:
    vertical_layout: fill
runtime: shiny
---

<style type="text/css">
  body {font-size: 16px;}
</style>


```{r setup, echo=FALSE, include=FALSE}

library(calval)
library(dplyr)
library(DT)
library(ggplot2)
library(here)
library(lubridate)
library(plotly)
library(readr)
library(sensorstrings)
library(shiny)
#library(shinyjs)
library(stringr)
library(tidyr)

```


```{r}
#########################################
###### Reactive UI ###################### 
#########################################

button_style <- "color: #fff; background-color: #063e4d; border-color: #063e4d"

output$compile_button <- renderUI({
  req(input$upload)
  
  actionButton(
    "compile", "Compile Data", 
    width = '100%',
    style = button_style,
    onclick = "location.href='#section-compiled-data';")
})

output$trim_start <- renderUI({
  dat <- compile_data()
  textInput(
    "ts_start", "First Good Timestamp",
    value = min(dat$timestamp_utc),
    width = '100%',
    placeholder = "yyyy-mm-dd hh:mm:ss"
  )
})

output$trim_end <- renderUI({
  dat <- compile_data()
  textInput(
    "ts_end", "Last Good Timestamp",
    value = max(dat$timestamp_utc),
    width = '100%',
    placeholder = "yyyy-mm-dd hh:mm:ss"
  )
})

output$trim_button <- renderUI({
  req(input$compile)
  actionButton(
    "apply_trim", 
    "Trim Data", 
    width = '100%',
    style = button_style,
    onclick = "location.href='#section-trimmed-data';")
})

output$val_button <- renderUI({
  req(input$compile)
  req(input$apply_trim)
  req(input$data_type == "Validation")
  
  actionButton(
    "apply_val", "Validate", 
    width = '100%',
    style = button_style,
    onclick = "location.href='#section-sensor-validation';")
})

output$clear_button <- renderUI({
 # req(input$upload)
 
  actionButton(
    "clear_data", "Refresh App", icon("arrows-rotate"),
    width = '100%'
  )
})

#########################################
###### Data Wrangling ################### 
#########################################

get_files <- reactive({
  req(input$upload)
  files <- unzip(input$upload$datapath, list = FALSE)
  files <- files[grep(".csv", files)]
  files <- files[grep("other_vemco", files, invert = TRUE)]
  
  return(files)
})

get_folder_name <- reactive({
  req(input$upload)
  
  files <- get_files()
  
  files <- sub("./", "", files[1])
  
  folder <- gsub("(.+?)(\\/.*)", "\\1", files)
  
  return(folder)
})

read_log <- reactive({
  req(input$upload)
  
  zip_files <- get_files()
  path <- zip_files[grep("log", zip_files)]
  
  ss_log <- ss_read_log(path, parse = FALSE, verbose = FALSE)
  
  return(ss_log)
})

compile_data <- eventReactive(input$compile, {
  req(input$data_type)
  
  zip_files <- get_files()
  
  depl_log <- read_log() %>% ss_parse_log(verbose = FALSE)
  depl_dates <- depl_log$deployment_dates
  sn_table <- depl_log$sn_table
  
  depl_data <- tibble(NULL)
  
  sn_am <- sn_table %>%
    filter(str_detect(log_sensor, regex("aquameasure", ignore_case = TRUE)))
  if(nrow(sn_am) > 0) {
    am <- ss_compile_aquameasure_data(
      path = zip_files[grep("aquameasure", zip_files)],
      sn_table = sn_table,
      deployment_dates = depl_dates,
      trim = TRUE
    )
    depl_data <- bind_rows(depl_data, am)
  }
  
  sn_hobo <- sn_table %>%
    filter(str_detect(log_sensor, regex("hobo", ignore_case = TRUE)))
  if(nrow(sn_hobo) > 0) {
    hobo <- ss_compile_hobo_data(
      path = zip_files[grep("hobo", zip_files)],
      sn_table = sn_table,
      deployment_dates = depl_dates,
      trim = TRUE
    )
    depl_data <- bind_rows(depl_data, hobo)
  }
  
  sn_tidbit <- sn_table %>%
    filter(str_detect(log_sensor, regex("tidbit", ignore_case = TRUE)))
  if (nrow(sn_tidbit) > 0) {
    tidbit <- ss_compile_hobo_data(
      path = zip_files[grep("tidbit", zip_files)],
      sn_table = sn_tidbit,
      deployment_dates = depl_dates,
      trim = TRUE,
      sensor_make = "tidbit"
    )
    depl_data <- bind_rows(depl_data, tidbit)
  }
  
  sn_vem <- sn_table %>%
    filter(str_detect(log_sensor, regex("VR2AR", ignore_case = TRUE)))
  if (nrow(sn_vem) > 0) {
    vemco <- ss_compile_vemco_data(
      path = zip_files[grep("vemco", zip_files)],
      sn_table = sn_vem,
      deployment_dates = depl_dates,
      trim = TRUE
    )
    depl_data <- bind_rows(depl_data, vemco)
  }
  
  if(input$data_type == "Validation") {
    depl_data <- depl_data %>% 
      select(-contains("sensor_depth"))
  }
  
  return(depl_data)
})


observeEvent(input$compile, {
  showModal(
    modalDialog(
      "Compiling data. This may take several minutes",
      easyClose = TRUE
    ))
})  


trim_data <- eventReactive(input$apply_trim, {
  ts_min <- as_datetime(input$ts_start)
  ts_max <- as_datetime(input$ts_end)
  
  validate(need(!is.na(ts_min), "Fix Timestamp: the timestamp entered into the First Good Timestamp field must be in the order yyyy-mm-dd hh:mm:ss"))
  validate(need(!is.na(ts_max), "Fix Timestamp: the timestamp entered into the Last Good Timestamp field must be in the order yyyy-mm-dd hh:mm:ss"))
  validate(need(ts_max > ts_min, "Fix Timestamps: the timestamp entered in the First Good Timestamp field must occur before the timestamp entered in the Last Good Timestamp field"))
    
  dat <- compile_data() %>% 
    filter(timestamp_utc >= ts_min, timestamp_utc <= ts_max)

  return(dat)
})


val_data <- eventReactive(input$apply_val, {
  dat <- trim_data() %>% 
    ss_pivot_longer() %>% 
    cv_round_timestamps() %>%
    cv_assign_tolerance_flag()

  return(dat)
})


# useShinyjs(rmd = TRUE)
observeEvent(input$clear_data, {

  session$reload()
  
  # #unlink(input$upload$datapath)
  # shinyjs::reset(id = "")
  # 
  # output$compile_button <- NULL
  # output$trim_start <- NULL
  # output$trim_end <- NULL
  # output$trim_button <- NULL
  # output$val_button <- NULL
  # 
  # output$p_raw <- NULL
  # output$p_trim <- NULL

})

#########################################
###### Figures & Tables ################## 
#########################################

ts_click <- reactive({
  req(input$compile)
  
  ts_info <- event_data("plotly_click", source = "plot1")
  
  if (is.null(ts_info)) {
      "Click a point from the chart above to print its timestamp. Double click the chart to clear."
  } else {
    ts_new <- data.frame(ts = as_datetime(ts_info$x))
    ts_new$ts <- format(ts_new$ts, "%Y-%m-%d %H:%M:%S")
    
    ts_new$ts
  }
  
})

ts_click_trim <- reactive({
  req(input$apply_trim)
  
  ts_info <- event_data("plotly_click", source = "plot2")
  
  if (is.null(ts_info)) {
      "Click a point from the chart above to print its timestamp. Double click the chart to clear."
  } else {
    ts_new <- data.frame(ts = as_datetime(ts_info$x))
    ts_new$ts <- format(ts_new$ts, "%Y-%m-%d %H:%M:%S")
    
    ts_new$ts
  }
})

customize_fig <- reactive({
  req(input$data_type)

  if(input$data_type == "Validation") {
    point_col <- "sensor_serial_number"
    point_size <- 1
    legend_name <- "Serial Number"
  }
  if(input$data_type == "Deployment") {
    point_col <- "sensor_depth_at_low_tide_m"
    point_size <- 0.25
    legend_name <- "Depth (m)"
  }

  return(data.frame(
    point_col = point_col, 
    point_size = point_size,
    legend_name = legend_name
  ))
  
})


plot_data_sn <- reactive({
  dat <- val_data() %>% 
    mutate(sensor_serial_number = factor(sensor_serial_number))
  
  p <- cv_plot_flags(dat, colour_col = "sensor_serial_number")
  
  return(p)
})

```


Column {.sidebar data-width=350}
=======================================

```{r}

selectInput(
  "data_type",
  "Select Data Type",
  choices = c("Deployment", "Validation"),
  selected = "Validation",
  width = '100%'
)

uiOutput("clear_button")
#HTML("<br>")

fileInput(
  "upload",
  "",
  accept = ".zip",
  buttonLabel = "Upload Zip File",
  multiple = FALSE,
  width = '100%'
)

uiOutput("compile_button")
HTML("<br>")

uiOutput("trim_start")

uiOutput("trim_end")

uiOutput("trim_button")
HTML("<br>")

uiOutput("val_button")

```

Instructions {data-icon="fa-circle-info"}
=======================================

Col {.tabset}
-------------------------------------

### Overview

Welcome to the [Centre for Marine Applied Research](https://cmar.ca/)'s (CMAR) Sensor Validation App. The app provides a user interface to validate the calibration of sensors deployed as part of CMAR's [Coastal Monitoring Program](https://cmar.ca/coastal-monitoring-program/).

The full Validation procedure is outlined in [CMAR's Sensor Validation Reference Sheet]().

Please follow the instructions in the tabs above to generate the validation results.

**Pay close attention the file format, folder structure, and metadata requirements, or else the app WILL NOT run as intended.** 

### **Step 1: Upload Zipped Data**

The data from a single validation test **must** be saved in a specific format and folder structure for the app to access.

- A separate data file must be offloaded from each sensor and saved in .csv format.
- The .csv files offloaded from hobo and tidbit sensors must be saved in a folder called "hobo" and named with the sensor serial number.
- The .csv files downloaded from aquameasure sensors must be saved in a folder named "aquameasure".
- The .csv files offloaded from VR2AR and VR2AR-X sensors must be saved in a folder named "vemco".

A metadata log with information about the validation must be saved in a folder called "log". The log must include a row for each sensor validated and the following columns:

- **deployment_date**: the date the validation test started, in ISO-8601 format, i.e. yyyy-mm-dd. Example: 2025-03-07. This must be the same for each row.
- **retrieval_date**: the date the validation test ended, in ISO-8601 format, i.e. yyyy-mm-dd. Example: 2025-03-10. This must be the same for each row.
- **sensor_type**: the manufacturer of the sensor being validated. Entries must include "aquameasure", "hobo", "tidbit", or "vr2ar". Example: "aquaMeasure DOT", "HOBO Pro V2".
- **sensor_serial_number**: serial number of the sensor being validated.

The aquameasure, hobo, tidbit, vemco, and/or log folders must all be saved in the same folder (e.g., validation_data). This folder must be saved as a zip file and may be uploaded to the app using the "Upload Zip File" button.


### **Step 2: Compile Data**

After the zip file with the validation data has been successfully uploaded, a "Compile Data" button will appear in the sideboard.

Several things happen When this button is clicked:
1. The app will automatically open the "Compiled Data" page.
2. A popup message will appear to signal that the data is being compiled.
3. Behind the scenes, the validation data from the different sensors will be compiled into a single data frame with additional metadata columns. Depending on the size of the data files, this could take a few minutes with little feedback. Be patient.

After the data has been compiled, the tabs in the Compiled Data page will be populated:

- **Figure**: an interactive figure displaying the data from all sensors in the validation, coloured by sensor serial number. 
  - Hover over points to see information including the timestamp, measurement value, sensor type, and sensor serial number. 
  - Click on entries in the legend to add/remove data series. 
  - Click and drag to zoom in on interesting features.
  - Download image by clicking the camera icon that appears in the top right of the figure.  
- **Data**: a table of compiled data. 
  - Search in the table using the "Search" bar.
  - Reorder the rows based on any column using the arrow in the column header.
  - Copy or download a csv of the data using the buttons in the top left. 
- **Log**: a copy of the log in the zip folder.
- **Uploaded Files**: a printout of the files found in the zip folder. 

See **Step 3: Trim Data** for explanation of the Timestamp inputs, Trim button, and "Print Timestamp" panel.

### **Step 3: Trim Data**

The compiled data may include observations from before or after the validation test that should not be included in the test statistics. These can be trimmed out of the dataset in this step.

First, identify the timestamp of the first "Good" observation, i.e., the first data point that should be included. It may be helpful to zoom in on the figure to do so. Double click to zoom back out. Clicking a data point will print its timestamp to the "Print Timestamp" panel. This can be copied and pasted into the "First Good Timestamp" text box in the side bar.

Follow a similar procedure to find the last good observation, and paste its timestamp in the "Last Good Timestamp" text box.

Click the "Trim Data" button. This will remove the observations before/after the first and last good observation. The "Trimmed Data" page will open and the tabs will be populated:

- **Figure**: an interactive figure displaying the data from all sensors in the validation trimmed to the specified dates and coloured by sensor serial number. 
  - Hover over points to see information including the timestamp, measurement value, sensor type, and sensor serial number. 
  - Click on entries in the legend to add/remove data series. 
  - Click and drag to zoom in on interesting features.
  - Download image by clicking the camera icon that appears in the top right of the figure.  
- **Data**: a table of trimmed data. 
  - Search in the table using the "Search" bar.
  - Reorder the rows based on any column using the arrow in the column header.
  - Copy or download a csv of the data using the buttons in the top left.
  
See **Step 4: Sensor Validation** for explanation of the Validate button.
  
### **Step 4: Sensor Validation**

After the data has been acceptably trimmed, click the Validate button. This will open the "Sensor Validation Page" and populate the tabs. 

- **Temperature/Dissolved Oxygen/Salinity**: there is a separate tab for the validation figure for each variable. The figure shows the data from each sensor and a gray band indicating the acceptable range.
  - The acceptable range is the median value of all observations in a 15-minute window +/- sensor precision.
- **Validation Data**: a table of validation data. Note that this is in a "long" format, i.e., the data for different variables is stacked on top of each other. Validation columns include:
  - round_timestamp: the timestamp rounded to the nearest 15-minute interval.
  - tolerance: the sensor accuracy, in the same units as the measurements.
  - med: the median value of the observations of a variable in a given 15-minute interval.
  - tol_lower: med - tolerance
  - tol_upper: med + tolerance
  - qc_flag: 1 if the value is within the upper and lower tolerance; 4 if the value if outside of this range.
- **Validation Results**: summary table indicating the percent of observations that passed (were within tolerance) and failed (were outside of tolerance) the validation. CMAR considers percent_pass >= 90 % acceptable for deployment. Other sensors are included in another validation test. Any sensor that fails 2 consecutive validations is sent to the manufacturer for service.

As with the other tables in the app:

  - Search in the table using the "Search" bar.
  - Reorder the rows based on any column using the arrow in the column header.
  - Copy or download a csv of the data using the buttons in the top left.

  
### Note

**Deployment Data**
This app was developed to review Validation data; however, it is possible to upload data from a sensor string deployment. To do so:

  - In the "Select Data Type" dropdown, choose "Deployment". This will colour the figures by sensor depth instead of serial number. 
  - Ensure the metadata log has the required columns (e.g. sensor_depth_m).

Note that it may take several minutes for the data to compile, with little feedback. Additionally, the interactive figures will slow to react to hover and zoom commands.

A separate app is being developed to work more conveniently with deployment data.

Compiled Data {data-orientation=rows data-icon="fa-table"}
=======================================

Col {.tabset}
-------------------------------------

### Figure
```{r}

output$p_raw <- renderPlotly({
  
  validate(need(input$compile, "No data to plot"))
  
  dat <- compile_data()
  
  fig_params <- customize_fig()
  
  p <- ss_ggplot_variables(
    dat, 
    color_col = fig_params$point_col,
    point_size = fig_params$point_size,
    legend_name = fig_params$legend_name,
    axis_label_newline = FALSE
  )
  
  p <- ggplotly(p, tooltip = "text", source = "plot1") %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "temperature_validation",
        width = 900, height = 500
      ))  %>%
    layout(margin = list(b = 90, l = 90))
  
  p
})

plotlyOutput("p_raw")
```

### Data
```{r}
renderDT({
  validate(need(input$compile, "No data to plot"))
  req(input$data_type)
  
  download_name <- paste0(get_folder_name(), "_compiled")
  
  compile_data() %>% 
    mutate(timestamp_utc = format(timestamp_utc)) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
        scrollY = "500px",
        scrollX = "500px",
        buttons = list(
          list(extend = 'copy', title = download_name), 
          list(extend = 'csv', title = download_name) 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
})
```

### Log
```{r}
renderDT({
  validate(need(input$compile, "No data to plot."))

  read_log() %>%
    datatable(
      rownames = FALSE,
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
        # scrollY = "500px",
        scrollX = "500px",
        columnDefs = list(list(className = 'dt-center', targets = "_all"))))
})
```

### Uploaded Files
```{r}
renderPrint({
  validate(need(input$upload, "No files uploaded"))
  get_files()
})
```

Col {data-height=50}
-------------------------------------

### Print Timestamp
```{r}
renderText(ts_click())
```


Trimmed Data {data-orientation=rows data-icon="fa-scissors"}
=======================================

Col {.tabset}
-------------------------------------

### Trimmed Data 
```{r}

output$p_trim <- renderPlotly({
  validate(need(input$apply_trim, "No trimmed data to plot"))

  dat <- trim_data()

  fig_params <- customize_fig()

  p <- ss_ggplot_variables(
    dat,
    color_col = fig_params$point_col,
    point_size = fig_params$point_size,
    legend_name = fig_params$legend_name,
    axis_label_newline = FALSE
  )

  p <- ggplotly(p, tooltip = "text", source = "plot2") %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "temperature_validation",
        width = 900, height = 500
      ))  %>%
    layout(margin = list(b = 90, l = 90))

  p
})

plotlyOutput("p_trim")

```

### Data 
```{r}
renderDT({
  validate(need(input$apply_trim, "No trimmed data"))

  download_name <- paste0(get_folder_name(), "_trimmed")
  
  trim_data() %>%
    mutate(timestamp_utc = format(timestamp_utc)) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
        scrollY = "500px",
        scrollX = "500px",
        buttons = list(
          list(extend = 'copy', title = download_name), 
          list(extend = 'csv', title = download_name) 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
})
```

Col {data-height=50}
-------------------------------------
### Print Timestamp
```{r}
renderText(ts_click_trim())
```

Sensor Validation {data-icon="fa-check"}
=======================================

Row {.tabset} 
-------------------------------------

### Temperature
```{r}

renderPlotly({
  validate(need(input$apply_trim, "No validation data to plot"))
  validate(need(input$data_type == "Validation", "No validation data to plot. Please choose 'Validation' from the 'Select Data Type' dropdown"))
  validate(need(input$apply_val, "No validation data to plot. Please click the 'Validate' button"))
  
  p_temp <- plot_data_sn()
  
  validate(
    need("temperature_degree_c" %in% names(p_temp), "No temperature data found"))
  
  ggplotly(p_temp$temperature_degree_c) %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "temperature_validation",
        width = 900, height = 500
      ))  %>%
    layout(margin = list(b = 90, l = 90))
})

```


### Dissolved Oxygen
```{r}

renderPlotly({
  validate(need(input$apply_trim, "No validation data to plot"))
  validate(need(input$data_type == "Validation", "No validation data to plot. Please choose 'Validation' from the 'Select Data Type' dropdown"))
  validate(need(input$apply_val, "No validation data to plot. Please click the 'Validate' button"))
  
  p_do <- plot_data_sn()
  
  validate(
    need("dissolved_oxygen_percent_saturation" %in% names(p_do), 
         "No dissolved oxygen data found")
  )
  
  ggplotly(p_do$dissolved_oxygen_percent_saturation) %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "dissolved_oxygen_percent_saturation_validation",
        width = 900, height = 500
      ))  
})

``` 


### Salinity

```{r}

renderPlotly({
  validate(need(input$apply_trim, "No validation data to plot"))
  validate(need(input$data_type == "Validation", "No validation data to plot. Please choose 'Validation' from the 'Select Data Type' dropdown"))
  validate(need(input$apply_val, "No validation data to plot. Please click the 'Validate' button"))
  
  p_sal <- plot_data_sn()
  
  validate(need("salinity_psu" %in% names(p_sal), "No salinity data found"))
  
  ggplotly(p$salinity_psu) %>%
    config(
      modeBarButtonsToRemove = list("toggleSpikelines", "autoScale2d"),
      displaylogo = FALSE,
      toImageButtonOptions = list(
        format = "png",
        filename = "salinity_validation",
        width = 900, height = 500)
    ) 
})

``` 

### Validation Data

```{r}
renderDT({
  validate(need(input$apply_trim, "No validation data to show"))
  validate(need(input$data_type == "Validation", "No validation data to show. Please choose 'Validation' from the 'Select Data Type' dropdown"))
  validate(need(input$apply_val, "No validation data to show. Please click the 'Validate' button"))
  
  download_name <- paste0(get_folder_name(), "_validation_data")

  val_data() %>%
    select(-deployment_range) %>% 
    mutate(
      timestamp_utc = format(timestamp_utc),
      round_timestamp = format(round_timestamp),
      med = round(med, digits = 2),
      tol_lower = round(tol_lower, digits = 2),
      tol_upper = round(tol_upper, digits = 2)
    ) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
       # scrollY = "500px",
        scrollX = "500px",
        buttons = list(
          list(extend = 'copy', title = download_name), 
          list(extend = 'csv', title = download_name) 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))
      )
    )
})
```

### Validation Results

```{r}
renderDT({
  validate(need(input$apply_trim, "No validation results to show"))
  validate(need(input$data_type == "Validation", "No validation results to show. Please choose 'Validation' from the 'Select Data Type' dropdown"))
  validate(need(input$apply_val, "No validation results to show. Please click the 'Validate' button"))
  
  download_name <- paste0(get_folder_name(), "_validation_results")
  
  val_data() %>% 
    cv_summarise_flags(dt = FALSE)  %>% 
    mutate(
      percent_pass = round(percent_pass, digits = 2),
      percent_fail = round(percent_fail, digits = 2)
    ) %>% 
    datatable(
      rownames = FALSE,
      extensions = 'Buttons',
      options = list(
        dom = 'Bft',
        paging = FALSE,
        searching = TRUE,
       # scrollY = "500px",
        scrollX = "500px",
        buttons = list(
          list(extend = 'copy', title = download_name), 
          list(extend = 'csv', title = download_name) 
        ),
        columnDefs = list(list(className = 'dt-center', targets = "_all"))))
})
```

